八大经典排序算法包括以下内容，每个算法的平均时间复杂度、空间复杂度如下：

### 1. **冒泡排序 (Bubble Sort)**  
**原理**: 每一轮将相邻的两个元素两两比较并交换，把最大的元素逐渐“冒泡”到数组末尾。
- **平均时间复杂度**: O(n²)
- **空间复杂度**: O(1)（原地排序，不需要额外空间）

### 2. **选择排序 (Selection Sort)**  
**原理**: 每一轮从未排序部分中选择最小的元素放到已排序部分的末尾。
- **平均时间复杂度**: O(n²)
- **空间复杂度**: O(1)

### 3. **插入排序 (Insertion Sort)**  
**原理**: 每一轮将当前元素插入到已排序的部分，使已排序部分保持有序。
- **平均时间复杂度**: O(n²)
- **空间复杂度**: O(1)

### 4. **快速排序 (Quick Sort)**  
**原理**: 选择一个枢轴元素，将数组分为两部分，递归地对两部分排序。
- **平均时间复杂度**: O(n log n)
- **空间复杂度**: O(log n)（递归栈空间）

### 5. **归并排序 (Merge Sort)**  
**原理**: 将数组分成两半，递归排序后合并两个有序部分。
- **平均时间复杂度**: O(n log n)
- **空间复杂度**: O(n)（需要额外的合并数组）

### 6. **堆排序 (Heap Sort)**  
**原理**: 构建一个最大堆（或最小堆），反复将堆顶元素移除并放入数组末尾。
- **平均时间复杂度**: O(n log n)
- **空间复杂度**: O(1)

### 7. **希尔排序 (Shell Sort)**  
**原理**: 通过不断缩小间隔对元素进行分组排序，直到最终进行标准的插入排序。
- **平均时间复杂度**: O(n log n) 到 O(n²)（取决于间隔序列）
- **空间复杂度**: O(1)

### 8. **计数排序 (Counting Sort)**  
**原理**: 通过计算每个元素出现的次数，直接定位元素在排序数组中的位置。
- **平均时间复杂度**: O(n + k)（n 是输入元素数量，k 是输入元素的范围）
- **空间复杂度**: O(n + k)（需要额外的计数数组）

### 总结表格

| 排序算法    | 平均时间复杂度 | 空间复杂度 |
|-------------|----------------|------------|
| 冒泡排序    | O(n²)          | O(1)       |
| 选择排序    | O(n²)          | O(1)       |
| 插入排序    | O(n²)          | O(1)       |
| 快速排序    | O(n log n)     | O(log n)   |
| 归并排序    | O(n log n)     | O(n)       |
| 堆排序      | O(n log n)     | O(1)       |
| 希尔排序    | O(n log n) - O(n²) | O(1)   |
| 计数排序    | O(n + k)       | O(n + k)   |

这些排序算法各有优劣，选择时要考虑数据规模、特征和算法的应用场景。